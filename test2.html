<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
	/*
	//数组截断
	//返回一个数组被截断n个元素后还剩余的元素，从索引0开始截断。
	   function slasher(arr, howMany) {
		// it doesn't always pay to be first
		arr.splice(0, howMany);
		return arr;
		}

		slasher([1, 2, 3], 2);
	*/

	//数组查询
	/* 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，则函数返回true。

举例，["hello", "Hello"]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。

["hello", "hey"]应该返回false，因为字符串"hello"并不包含字符"y"。

["Alien", "line"]应该返回true，因为"line"中所有字符都可以在"Alien"找到。
function mutation(arr) {
arr[0]=arr[0].toLowerCase();
var newarr = arr[1].toLowerCase().split("");
for(var i=0;i<newarr.length;i++){
	if(arr[0].indexOf(newarr[i])<0){
		return false;
	}
}
return true;
}

mutation(["Hello", "Hey"]);
*/
/*删除数组中特定值

删除数组中的所有的假值。

在JavaScript中，假值有false、null、0、""、undefined 和 NaN。


function bouncer(arr) {
// Don't show a false ID to this bouncer.
var newarr = arr.filter(function(value){
	var x =new Boolean(value);
	if(x==true){
		return value;
	}
	
});
return newarr;
}

bouncer([7, "ate", "", false, 9]);
*/

/*去除数组中任意多个值
实现一个 destroyer 函数，第一个参数是初始数组，后跟一个或多个参数。从初始数组中删除与这些参数具有相同值的所有元素。


function destroyer(arr) {
// Remove all the values
	var args=Array.prototype.slice.call(arguments); 
	console.log(args);
	var newargs = args[0].filter(function(value){
		var result = true;
		for(var i=1;i<args.length;i++){
			if(value != args[i]){
				result = result
			}else{
				result=result&&false
			}
		}
		return result;
		
		// var result=true;
  // for(var i=1;i<args.length;i++){
  //   if(args[i]===item)
  //     {
  //       result=result&&false;
  //     }else
  //     {
  //       result=result&&true;
  //     }
  // }
  // return result;

	});
	console.log(newargs);
	// for(var i=0;i<arguments.length;i++){
	// 	console.log(arguments[i])
	// }
 return newargs;
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);
*/

/*

数组排序并插入值
 先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。

举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。

同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。
 

function where(arr, num) {
// Find my place in this sorted array.
arr.push(num);
arr.sort(function(a,b){
	return a-b;
})
var c;
for(var i=0;i<arr.length;i++){
	console.log(arr[i])
	if(arr[i]==num){
		
		c=i;
		break;
	}

}
console.log(arr)
console.log(c)
return c;
}

where([40, 60,30,50], 50);*/
/*位移密码
下面我们来介绍著名的凯撒密码Caesar cipher，又叫移位密码。

移位密码也就是密码中的字母会按照指定的数量来做移位。

一个常见的案例就是ROT13密码，字母会移位13个位置。由'A' ↔ 'N', 'B' ↔'O'，以此类推。

写一个ROT13函数，实现输入加密字符串，输出解密字符串。

所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，就跳过它们。
*/
function rot13(str) { // LBH QVQ VG!
	var strArr=[];
	for(var i=0;i<str.length;i++){
		strArr.push(str.charCodeAt(i));
	}
for(var j=0;j<strArr.length;j++){
	if('A'.charCodeAt(0)<=strArr[j]&&strArr[j]<='Z'.charCodeAt(0)){
		strArr[j]+=13;
		if(strArr[j]>'Z'.charCodeAt(0)){
			strArr[j]='A'.charCodeAt(0)+strArr[j]-'Z'.charCodeAt(0)-1;
		}
	}
}
str="";
strArr.forEach(function(element) {
	console.log(element);
	return str+=String.fromCharCode(element);
});
return str;
}

// Change the inputs below to test
rot13("SERR PBQR PNZC");

	</script>
</body>
</html>